---
description: Generate implementation tasks for a specification
allowed-tools: Bash, Read, Write, Edit, Update, MultiEdit
---

# 実装タスク

機能の詳細な実装タスクを生成: **$ARGUMENTS**

## インタラクティブ承認: 要件と設計のレビュー

**重要**: タスクは要件と設計の両方がレビューされ承認された後にのみ生成できます。

### インタラクティブレビュープロセス

- 要件文書: @spec/specs/$ARGUMENTS/requirements.md
- 設計文書: @spec/specs/$ARGUMENTS/design.md
- 仕様メタデータ: @spec/specs/$ARGUMENTS/spec.json

**インタラクティブ承認プロセス**:

1. **文書が存在するか確認** - requirements.mdとdesign.mdが生成されていることを確認
2. **要件レビューをプロンプト** - ユーザーに確認: "requirements.mdをレビューしましたか？ [y/N]"
3. **設計レビューをプロンプト** - ユーザーに確認: "design.mdをレビューしましたか？ [y/N]"
4. **両方とも'y'（はい）の場合**: spec.jsonを自動的に更新して両方のフェーズを承認し、タスク生成を続行
5. **いずれかが'N'（いいえ）の場合**: 実行を停止し、該当する文書を最初にレビューするようユーザーに指示

**ユーザーが両方のレビューを確認したときのspec.jsonの自動承認更新**:

```json
{
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true // ← ユーザーが確認したとき自動的にtrueに設定
    },
    "design": {
      "generated": true,
      "approved": true // ← ユーザーが確認したとき自動的にtrueに設定
    }
  },
  "phase": "design-approved"
}
```

**ユーザーインタラクションの例**:

```
📋 タスク生成前に要件と設計のレビューが必要です。
📄 レビューしてください: spec/specs/feature-name/requirements.md
❓ requirements.mdをレビューしましたか？ [y/N]: y
📄 レビューしてください: spec/specs/feature-name/design.md
❓ design.mdをレビューしましたか？ [y/N]: y
✅ 要件と設計を自動的に承認しました。タスク生成を続行します...
```

## コンテキスト分析

### 完全な仕様コンテキスト（承認済み）

- 要件: @spec/specs/$ARGUMENTS/requirements.md
- 設計: @spec/specs/$ARGUMENTS/design.md
- 現在のタスク: @spec/specs/$ARGUMENTS/tasks.md
- 仕様メタデータ: @spec/specs/$ARGUMENTS/spec.json

### ステアリングコンテキスト

- アーキテクチャパターン: @spec/steering/structure.md
- 開発プラクティス: @spec/steering/tech.md
- プロダクト制約: @spec/steering/product.md

## タスク: コード生成プロンプトの生成

**前提条件の確認**: 要件と設計の両方が承認され、タスク分解の準備ができています。

**重要**: 機能設計を、各ステップをテスト駆動方式で実装するコード生成LLM向けの一連のプロンプトに変換します。ベストプラクティス、漸進的な進歩、早期テストを優先し、どの段階でも複雑さに大きな飛躍がないようにします。

spec.jsonで指定された言語で実装計画を作成：

### 1. コード生成タスクの構造

spec.jsonで指定された言語でtasks.mdを作成（`@spec/specs/$ARGUMENTS/spec.json`の"language"フィールドを確認）：

```markdown
# 実装計画

この文書は要件 @requirements.md、設計 @design.md を元に作成され、設計を実現させるための実装計画です。

各タスクは2時間以内を目安に完了できる内容となっています。

- [ ] 1. プロジェクト構造とコアインターフェースのセットアップ
  - モデル、サービス、リポジトリ、APIコンポーネント用のディレクトリ構造を作成
  - 後続のタスクで実装されるインターフェースを定義
  - テスト駆動開発用のテストフレームワークをセットアップ
  - _要件: 1.1_

- [ ] 2. テスト駆動アプローチでデータモデルを実装
- [ ] 2.1 ベースモデル機能の作成
  - 最初にベースモデルの動作のテストを記述
  - テストに合格するベースEntityクラスを実装
  - 共通プロパティと検証メソッドを含める
  - _要件: 2.1, 2.2_

- [ ] 2.2 検証機能付きユーザーモデルの実装
  - 検証エッジケースを含むユーザーモデルテストを記述
  - メール検証とパスワードハッシュ機能を持つUserクラスを作成
  - エッジケースをテスト: 無効なメール、弱いパスワード、重複ユーザー
  - _要件: 1.2, 1.3_

- [ ] 2.3 関係性を持つプライマリドメインモデルの実装
  - 関係性を含む[ドメイン]モデルのテストを記述
  - 関係性処理を持つ[ドメイン]クラスをコーディング
  - ビジネスロジックと検証ルールを実装
  - _要件: 2.3, 2.4_

- [ ] 3. テスト駆動アプローチでデータアクセス層を作成
- [ ] 3.1 データベース接続ユーティリティの実装
  - 最初にデータベース接続シナリオのテストを記述
  - テストに合格する接続ユーティリティを実装
  - エラーハンドリングとコネクションプールを追加
  - _要件: 3.1_

- [ ] 3.2 ユーザーデータアクセス用のリポジトリパターンの実装
  - 最初にCRUD操作のリポジトリテストを記述
  - 標準的なデータ操作を持つユーザーリポジトリを実装
  - 作成、読み取り、更新、削除シナリオをテスト
  - _要件: 3.2, 3.3_

- [ ] 3.3 ドメイン固有リポジトリの実装
  - ドメインリポジトリ操作のテストを記述
  - ビジネス固有クエリを持つ[ドメイン]リポジトリをコーディング
  - 関係性ローディングとフィルタリング機能を含める
  - _要件: 3.4_

- [ ] 4. テストファーストアプローチでAPI層を構築
- [ ] 4.1 認証サービスとエンドポイントの作成
  - 最初に認証フローのAPIテストを記述
  - ログインと登録メソッドを持つAuthServiceを構築
  - JWTトークン生成と検証を実装
  - 適切なエラーハンドリングを持つ認証エンドポイントを作成
  - _要件: 4.1, 4.2_

- [ ] 4.2 コアAPIエンドポイントの実装
  - 最初にドメイン操作のAPIテストを記述
  - ビジネスロジックを持つ[ドメイン]サービスをコーディング
  - 検証とエラーハンドリングを持つRESTエンドポイントを作成
  - 保護されたルート用の認証ミドルウェアを実装
  - _要件: 4.3, 4.4_

- [ ] 5. 統合テスト付きフロントエンドコンポーネントの作成
- [ ] 5.1 基礎的なUIコンポーネントの構築
  - 最初にUI要素のコンポーネントテストを記述
  - 再利用可能なコンポーネント（Button、Input、Form）を作成
  - コンポーネントレンダリング、プロパティ、ユーザーインタラクションをテスト
  - _要件: 5.1_

- [ ] 5.2 認証コンポーネントの実装
  - 最初に認証コンポーネントの動作のテストを記述
  - LoginFormとRegisterFormコンポーネントをコーディング
  - 認証用のAPI統合を実装
  - ローディング状態とエラーメッセージを処理
  - _要件: 5.2, 5.3_

- [ ] 5.3 メイン機能コンポーネントの構築
  - ドメインコンポーネントインタラクションのテストを記述
  - [ドメイン]Listと[ドメイン]Formコンポーネントを実装
  - データ操作用のAPI統合を追加
  - 適切なフィードバックを持つCRUD操作を処理
  - _要件: 5.4, 5.5_

- [ ] 6. すべてのコンポーネントを統合し、統合を検証
- [ ] 6.1 メインアプリケーション統合の作成
  - 完全なアプリケーションフローの統合テストを記述
  - アプリケーションルーティングとナビゲーションを実装
  - 保護されたルート用の認証ガードをセットアップ
  - すべてのコンポーネントが設計通りに連携することを確認
  - _要件: 6.1_

- [ ] 6.2 自動化されたエンドツーエンドテストの実装
  - 完全なユーザーワークフローをカバーするE2Eテストを記述
  - 認証フローをテスト: 登録 → ログイン → ログアウト
  - CRUD操作を持つメイン機能ワークフローをテスト
  - 完全なシステム統合を検証
  - _要件: 6.2_
```

**コード生成プロンプト形式ルール**:

- 階層番号付け: 主要フェーズ（1、2、3）とサブタスク（1.1、1.2）
- 各タスクはステップを実装するコード生成LLM向けのプロンプト
- 何を作成/修正するかを指定するが、実装詳細は設計文書に依存
- 漸進的に構築: 各タスクは明示的に前のタスクの出力を参照
- 適切な場合はテストから開始（テスト駆動開発）
- 各タスクは後続のタスクとの接続を説明
- 特定の要件マッピングで終了: _要件: X.X, Y.Y_
- コードの記述、修正、テストのみに焦点
- タスクはそれぞれ1〜3時間で完了可能である必要があります
- 最終タスクは孤立したコードを防ぐためにすべてを統合する必要があります

### 2. コード生成品質ガイドライン

- **プロンプト最適化**: 各タスクはコーディングエージェントが実行できる明確なプロンプト
- **段階的構築**: 使用される前のタスク出力を明示的に述べる
- **テストファーストアプローチ**: 適切な場合は実装前にテストを記述
- **前方参照**: 現在のタスク出力が後で使用される方法を説明
- **要件トレーサビリティ**: requirements.mdの特定のEARS要件にマッピング
- **統合焦点**: 最終タスクはすべてのコンポーネントを統合する必要があります
- **コーディングのみの焦点**: デプロイ、ユーザーテスト、非コーディング活動を除外
- **設計文書依存**: タスクは実装詳細を設計から参照

### 3. 必須タスクカテゴリ（コーディングのみ）

以下のコーディングタスクのみを含める:

- **データモデル**: 検証とテストを含むモデルクラス
- **データアクセス**: テスト付きリポジトリパターン実装
- **APIサービス**: APIテスト付きバックエンドサービス実装
- **UIコンポーネント**: コンポーネントテスト付きフロントエンドコンポーネント開発
- **統合**: コード統合と自動テスト
- **エンドツーエンドテスト**: 自動テスト実装

**除外（非コーディングタスク）:**

- ユーザー受け入れテストやユーザーフィードバック収集
- 本番デプロイやステージング環境
- パフォーマンスメトリクス収集や分析
- CI/CDパイプラインのセットアップや設定
- ドキュメント作成（コードコメント以外）

### 4. 詳細な要件マッピング

各タスクについて、requirements.mdの特定のEARS要件を参照：

- ユーザーストーリーだけでなく、詳細なサブ要件を参照
- 特定の受け入れ基準にマッピング（例：REQ-2.1.3: IF検証が失敗したらTHEN...）
- すべてのEARS要件が実装タスクでカバーされていることを確認
- 形式を使用: _要件: 2.1, 3.3, 1.2_（番号付き要件を参照）

### 6. ドキュメント生成のみ

タスクドキュメントのコンテンツのみを生成してください。実際のドキュメントファイルにレビューや承認の指示を含めないでください。

### 7. メタデータの更新

spec.jsonを更新：

```json
{
  "phase": "tasks-generated",
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true
    },
    "design": {
      "generated": true,
      "approved": true
    },
    "tasks": {
      "generated": true,
      "approved": false
    }
  },
  "updated_at": "現在のタイムスタンプ"
}
```

### 8. メタデータ更新

タスク生成完了を反映するように追跡メタデータを更新します。

---

## インタラクティブ承認の実装（ドキュメントに含まれない）

以下はClaude Codeの会話専用 - 生成されたドキュメントには含まれません：

### インタラクティブ承認プロセス

このコマンドは最終フェーズのインタラクティブ承認を実装：

1. **要件と設計のレビュープロンプト**: 両方の文書がレビューされていることをユーザーに自動的に確認をプロンプト
2. **自動承認**: ユーザーが両方を'y'で確認したときspec.jsonを自動的に更新
3. **タスク生成**: 二重承認後すぐに続行
4. **実装準備完了**: タスクが生成され、`/spec:implement`による実装フェーズの準備完了

### 実装フェーズのタスクレビュー

tasks.mdを生成した後、次のフェーズ（`/spec:implement $ARGUMENTS`）は同様のインタラクティブ承認を使用：

**次のインタラクションのプレビュー**:

```
📋 実装前にタスクレビューが必要です。
📄 レビューしてください: spec/specs/feature-name/tasks.md
❓ tasks.mdをレビューしましたか？ [y/N]:
```

### レビューチェックリスト（ユーザー参照用）：

- [ ] タスクが適切なサイズ（2時間以内に完了できる）
- [ ] すべての要件がタスクでカバーされている
- [ ] タスクの依存関係が正しい
- [ ] 技術選択が設計と一致している
- [ ] テストタスクが含まれている

## 指示

1. **spec.jsonで言語を確認** - メタデータで指定された言語を使用
2. **設計をコード生成プロンプトに変換** - 各タスクは特定のコーディング指示である必要があります
3. **テスト駆動アプローチを適用** - 各開発タスクにテストを統合
4. **正確なファイルとコンポーネントを指定** - どのファイルでどのコードを記述/修正するかを定義
5. **漸進的に構築** - 各タスクは前のタスクの出力を使用、孤立したコードなし
6. **詳細な要件にマッピング** - 特定のEARS受け入れ基準を参照
7. **コーディングのみに焦点** - デプロイ、ユーザーテスト、パフォーマンス分析を除外
8. **依存関係順に並べる** - 論理的な構築シーケンスを確保
9. **第三者による最終レビュー** - ユーザに見せる前に、Gemini にレビューしてもらいましょう。`gemini -p 'spec/specs/$ARGUMENTS/tasks.mdをレビューしてください'` を実行し、指摘内容から修正すべき点を修正しましょう
10. 完了時に**追跡メタデータを更新**

コーディングエージェント向けの段階的な実装指示を提供するコード生成プロンプトを生成します。
