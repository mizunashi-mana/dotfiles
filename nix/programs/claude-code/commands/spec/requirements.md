---
description: Generate comprehensive requirements for a specification
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Update, WebSearch, WebFetch
---

# 要件の生成

機能の包括的な要件を生成: **$ARGUMENTS**

## コンテキストの検証

### ステアリングコンテキスト

- アーキテクチャコンテキスト: @spec/steering/structure.md
- 技術的制約: @spec/steering/tech.md
- プロダクトコンテキスト: @spec/steering/product.md

### 既存の仕様コンテキスト

- 現在の仕様ディレクトリ: !`ls -la spec/specs/$ARGUMENTS/`
- 現在の要件: @spec/specs/$ARGUMENTS/requirements.md
- 仕様メタデータ: @spec/specs/$ARGUMENTS/spec.json

## タスク: 初期要件の生成

機能のアイデアに基づいてEARS形式で初期要件セットを生成し、完全で正確になるまでユーザーと反復して洗練します。

このフェーズではコード探索に焦点を当てないでください。代わりに、後で設計に変換される要件の作成に集中してください。

### 要件生成ガイドライン

1. **コア機能に焦点**: ユーザーのアイデアからの必須機能から開始
2. **EARS形式を使用**: すべての受け入れ基準は適切なEARS構文を使用する必要があります
3. **フィードバック前提**: 最初は初期版であり、ユーザーからのフィードバックを基に修正していくことを前提にしましょう
4. **管理可能に保つ**: ユーザーレビューを通じて拡張可能な堅実な基盤を作成

### 1. EARS形式の要件

**EARS（Easy Approach to Requirements Syntax）**は受け入れ基準の必須形式です：

**主要なEARSパターン：**

- **振る舞い:**【イベント/条件】**の時**【システム】**は**【応答】**しなければならない**
- **条件分岐:**【前提条件/状態】**の場合**【システム】**は**【応答】**しなければならない**
- **継続条件:**【継続条件】**の間**【継続的な動作】**を継続しなければならない**
- **コンテキスト:**【場所/コンテキスト】**では**【コンテキスト的な動作】**しなければならない**

**組み合わせパターン：**

- **振る舞い:**【イベント】**の時で**【追加条件】**の場合**【システム】**は**【応答】**しなければならない**
- **条件分岐:**【条件】**かつ**【追加条件】**の場合**【システム】**は**【応答】**しなければならない**

### 2. 要件の階層と粒度

**明確な階層で要件を構造化：**

```
# 要件文書
├── はじめに（機能概要）
├── 要件
│   ├── 要件1（主要機能エリア）
│   │   ├── ユーザーストーリー（高レベルのニーズ）
│   │   └── 受け入れ基準（詳細なEARS）
│   │       ├── ハッピーパスシナリオ
│   │       ├── エッジケースとエラー条件
│   │       ├── ユーザーエクスペリエンスの考慮事項
│   │       └── 技術的制約
│   ├── 要件2（次の機能エリア）
│   └── ...
```

**粒度ガイドライン：**

- **高レベル要件**: 機能アイデアからの主要な機能エリア
- **ユーザーストーリー**: 各要件エリア内の特定のユーザーニーズ
- **受け入れ基準**: EARS形式を使用したテスト可能な条件

### 3. 要件文書の構造

spec.jsonで指定された言語でrequirements.mdを生成（`@spec/specs/$ARGUMENTS/spec.json`の"language"フィールドを確認）：

```markdown
# 要件文書

この文書は要件をまとめたものです。後で設計に変換されることを前提に、コーディング方法などの詳細を省いており、必須の振る舞いや制約を明示するものです。

設計については @design.md を参照してください。

## はじめに

【機能とそのビジネス価値を要約した明確な導入】

## 要件

### 要件1: 【主要機能エリア】

**ユーザーストーリー:** 【ロール】として、【機能】が欲しい、そうすれば【利益】

#### 受け入れ基準

このセクションにはEARS要件を含める必要があります

1. **振る舞い:**【イベント/条件】の時【システム】は【応答】しなければならない
2. **条件分岐:**【前提条件/状態】の場合【システム】は【応答】しなければならない
3. **継続条件:**【継続条件】の間【継続的な動作】を継続しなければならない
4. **コンテキスト:**【場所/コンテキスト】では【コンテキスト的な動作】しなければならない

### 要件2: 【次の主要機能エリア】

**ユーザーストーリー:** 【ロール】として、【機能】が欲しい、そうすれば【利益】

1. **振る舞い:**【イベント】の時で【追加条件】の場合【システム】は【応答】しなければならない
2. **条件分岐:**【条件】かつ【追加条件】の場合【システム】は【応答】しなければならない

### 要件3: 【追加の主要エリア】

【すべての主要機能エリアに対してパターンを継続】
```

### 4. メタデータの更新

spec.jsonを更新：

```json
{
  "phase": "requirements-generated",
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": false
    }
  },
  "updated_at": "現在のタイムスタンプ"
}
```

### 5. ドキュメント生成のみ

要件文書のコンテンツのみを生成してください。実際のドキュメントファイルにレビューや承認の指示を含めないでください。

---

## インタラクティブ承認利用可能（ドキュメントに含まれない）

以下はClaude Codeの会話専用 - 生成されたドキュメントには含まれません：

### 次のフェーズでインタラクティブ承認を使用

requirements.mdを生成した後、次のフェーズ（`/spec:design $ARGUMENTS`）はインタラクティブ承認を使用：

**次のインタラクションは**：

```
/spec:design 機能名
# → "requirements.mdをレビューしましたか？ [y/N]"
# → 'y'の場合: 自動承認 + 設計生成
# → 'N'の場合: 停止して最初にレビューを要求
```

### インタラクティブ承認の利点

1. **効率化されたワークフロー**: 手動のspec.json編集が不要
2. **レビューの強制**: 人間によるレビュー確認は依然として必要
3. **即座の進行**: 承認されたフェーズは自動的に進行
4. **安全性の維持**: 'N'応答は適切なレビューのために実行を停止

### レビューチェックリスト（ユーザー参照用）：

- [ ] 要件が明確で完全
- [ ] ユーザーストーリーが必要なすべての機能をカバー
- [ ] 受け入れ基準がテスト可能
- [ ] 要件がプロジェクト目標と整合

### 従来の手動承認も引き続き利用可能

必要に応じて、`spec/specs/$ARGUMENTS/spec.json`を更新して手動で承認することもできます：

```json
{
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true
    }
  },
  "phase": "requirements-approved"
}
```

**推奨**: より良いユーザーエクスペリエンスのために`/spec-design $ARGUMENTS`でインタラクティブ承認を使用してください。

## 指示

1. **spec.jsonで言語を確認** - メタデータで指定された言語を使用
2. 最初に連続した質問をすることなく、機能アイデアに基づいて**初期要件を生成**
3. **EARS形式を適用** - すべての受け入れ基準に適切なEARS構文パターンを使用
4. **コア機能に焦点** - 必須機能とユーザーワークフローから開始
5. **明確に構造化** - 関連機能を論理的な要件エリアにグループ化
6. **要件をテスト可能にする** - 各受け入れ基準は検証可能である必要があります
7. **第三者によるレビュー** - ユーザに見せる前に、Gemini にレビューしてもらいましょう。`gemini -p 'spec/specs/$ARGUMENTS/requirements.mdをレビューしてください'` を実行し、指摘内容から修正すべき点を修正しましょう
8. 完了時に**追跡メタデータを更新**

機能アイデアからのコア機能に焦点を当てて、設計フェーズの堅実な基盤を提供する要件を生成します。
